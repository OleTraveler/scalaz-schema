<html><head><title>Scalaz-Schema: Recursive data types</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Scalaz-schema contributors" /><meta name="description" content="Abstract over data structures in a principled, purely functional way" /><meta name="og:image" content="/scalaz-schema/img/poster.png" /><meta name="image" property="og:image" content="/scalaz-schema/img/poster.png" /><meta name="og:title" content="Scalaz-Schema: Recursive data types" /><meta name="title" property="og:title" content="Scalaz-Schema: Recursive data types" /><meta name="og:site_name" content="Scalaz-Schema" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Abstract over data structures in a principled, purely functional way" /><link rel="icon" type="image/png" href="/scalaz-schema/img/favicon.png" /><meta name="twitter:title" content="Scalaz-Schema: Recursive data types" /><meta name="twitter:image" content="/scalaz-schema/img/poster.png" /><meta name="twitter:description" content="Abstract over data structures in a principled, purely functional way" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="512x512" href="/scalaz-schema/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalaz-schema/highlight/styles/default.css" /><link rel="stylesheet" href="/scalaz-schema/css/style.css" /><link rel="stylesheet" href="/scalaz-schema/css/palette.css" /><link rel="stylesheet" href="/scalaz-schema/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalaz-schema/" class="brand"><div class="brand-wrapper"><span>Scalaz-Schema</span></div></a></li>  <li><a href="/scalaz-schema/interpreters/" class="">Interpreters</a> <ul class="sub_section"> <li><a href="/scalaz-schema/interpreters/recursive-datatypes.html" class=" active ">Recursive data types</a></li> <li><a href="/scalaz-schema/interpreters/scalacheck.html" class="">Scalacheck Generators</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/scalaz/scalaz-schema"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/scalaz/scalaz-schema"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Scalaz-Schema Abstract over data structures in a principled, purely functional way');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Scalaz-Schema Abstract over data structures in a principled, purely functional way');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="scalaz" data-github-repo="scalaz-schema"><div class="content-wrapper"><section><h1 id="recursive-data-types">Recursive data types</h1>

<p>It is quite easy to define schemas for recursive data types, but extra care must be taken when it comes to derive functors from such schemas. In fact, there is possibility of non-termination at two distinct levels:</p>
<ul>
  <li>when building the interpreter</li>
  <li>when “running” the resulting functor</li>
</ul>

<h2 id="building-interpreters">Building interpreters</h2>

<p>The construction of an interpreter is guarantied to terminate under certain conditions. The <code class="highlighter-rouge">SelfReference</code> case of the <code class="highlighter-rouge">SchemaF</code> ADT has a lazy <code class="highlighter-rouge">unroll</code> field that “performs the recursion”. Evaluating this field eagerly in an algebra will make the interpretation diverge, but keeping it unevaluated will guarantee the interpretation to terminate.</p>

<p>For example, if we were to write an interpreter for <code class="highlighter-rouge">org.scalacheck.Gen</code> (that is, to implement an <code class="highlighter-rouge">HAlgebra[Schema, Gen]</code>), writing the following makes the process diverge:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...
</span>  <span class="k">case</span> <span class="n">ref</span> <span class="k">@</span> <span class="nc">SelfReference</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ref</span><span class="o">.</span><span class="n">unroll</span>
<span class="c1">// ...
</span></code></pre></div></div>

<p>The evaluation of <code class="highlighter-rouge">ref.unroll</code> causes the application of a natural transformation to the (self-) referenced schema. This natural transformation is the composition of several “smaller” natural transformations <em>including the algebra we are defining here</em>. This causes <code class="highlighter-rouge">ref.unroll</code> being evaluated over and over until the stack blows up.</p>

<p>That’s why <strong><code class="highlighter-rouge">ref.unroll</code> should never be evaluated within an algebra</strong>.</p>

<p>But if we keep the <code class="highlighter-rouge">unroll</code> field unevaluated, by passing it as a by-name parameter to some other function or by putting it in the body of an anonymous function, we are safe:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...
</span>  <span class="k">case</span> <span class="n">ref</span> <span class="k">@</span> <span class="nc">SelfReference</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">delay</span><span class="o">(</span><span class="n">ref</span><span class="o">.</span><span class="n">unroll</span><span class="o">)</span>
<span class="c1">//...
</span></code></pre></div></div>

<h2 id="non-termination-of-the-derived-functor">Non-termination of the derived functor</h2>

<p>It is impossible to guarantee non-termination of a derived functor in general, but here are a few tips.</p>

<ul>
  <li>Contravariant functors resembling to a function <code class="highlighter-rouge">A =&gt; X</code> (like, for example, <code class="highlighter-rouge">play.api.libs.json.Writes</code>) are safe as long as the input data is acyclic.</li>
  <li>Covariant functors resembling to a function <code class="highlighter-rouge">X =&gt; A</code> (like <code class="highlighter-rouge">play.api.libs.json.Reads</code>) are generaly safe, as long as you can prove that “each step consumes a bit of the <code class="highlighter-rouge">X</code>”.</li>
  <li>Covariant functors resembling to a function <code class="highlighter-rouge">() =&gt; A</code> (like <code class="highlighter-rouge">org.scalacheck.Gen</code>) are unsafe, unless they provide some “delay mechanism”.</li>
</ul>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalaz-schema/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'scalaz/scalaz-schema'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalaz-schema/js/main.js"></script></body></html>